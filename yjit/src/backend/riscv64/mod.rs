use std::mem::take;

use crate::asm::riscv64::*;
use crate::asm::{CodeBlock, OutlinedCb};
use crate::backend::ir::*;
use crate::cruby::*;
use crate::utils::*;
use crate::virtualmem::CodePtr;

// Use the riscv64 register type for this platform
pub type Reg = RV64Reg;

// Callee-saved registers
pub const _CFP: Opnd = Opnd::Reg(X19_REG);
pub const _EC: Opnd = Opnd::Reg(X20_REG);
pub const _SP: Opnd = Opnd::Reg(X21_REG);

// C argument registers on this platform
pub const _C_ARG_OPNDS: [Opnd; 6] = [
    Opnd::Reg(X0_REG),
    Opnd::Reg(X1_REG),
    Opnd::Reg(X2_REG),
    Opnd::Reg(X3_REG),
    Opnd::Reg(X4_REG),
    Opnd::Reg(X5_REG),
];

// C return value register on this platform
pub const C_RET_REG: Reg = X0_REG;
pub const _C_RET_OPND: Opnd = Opnd::Reg(X0_REG);

// These constants define the way we work with RISCV64's stack pointer. The stack
// pointer always needs to be aligned to a 16-byte boundary.
pub const C_SP_REG: RV64Opnd = RV64Opnd::Reg(X2_REG);
pub const C_SP_STEP: i32 = 16;

impl CodeBlock {
    // The maximum number of bytes that can be generated by emit_jmp_ptr.
    // pub fn jmp_ptr_bytes(&self) -> usize {
    //     // b instruction's offset is encoded as imm26 times 4. It can jump to
    //     // +/-128MiB, so this can be used when --yjit-exec-mem-size <= 128.
    //     let num_insns = if b_offset_fits_bits(self.virtual_region_size() as i64 / 4) {
    //         1 // b instruction
    //     } else {
    //         5 // 4 instructions to load a 64-bit absolute address + br instruction
    //     };
    //     num_insns * 4
    // }

    // The maximum number of instructions that can be generated by emit_conditional_jump.
    fn conditional_jump_insns(&self) -> i32 {
        // The worst case is instructions for a jump + bcond.
        self.jmp_ptr_bytes() as i32 / 4 + 1
    }
}

/// Map Opnd to RV64Opnd
impl From<Opnd> for RV64Opnd {
    fn from(opnd: Opnd) -> Self {
        match opnd {
            Opnd::UImm(value) => RV64Opnd::new_uimm(value),
            Opnd::Imm(value) => RV64Opnd::new_imm(value),
            Opnd::Reg(reg) => RV64Opnd::Reg(reg),
            Opnd::Mem(Mem { base: MemBase::Reg(reg_no), num_bits, disp }) => {
                RV64Opnd::new_mem(reg_no,  disp)
            },
            Opnd::Mem(Mem { base: MemBase::InsnOut(_), .. }) => {
                panic!("attempted to lower an Opnd::Mem with a MemBase::InsnOut base")
            },
            Opnd::CArg(_) => panic!("attempted to lower an Opnd::CArg"),
            Opnd::InsnOut { .. } => panic!("attempted to lower an Opnd::InsnOut"),
            Opnd::Value(_) => panic!("attempted to lower an Opnd::Value"),
            Opnd::Stack { .. } => panic!("attempted to lower an Opnd::Stack"),
            Opnd::None => panic!(
                "Attempted to lower an Opnd::None. This often happens when an out operand was not allocated for an instruction because the output of the instruction was not used. Please ensure you are using the output."
            ),

        }
    }
}

/// Also implement going from a reference to an operand for convenience.
impl From<&Opnd> for RV64Opnd {
    fn from(opnd: &Opnd) -> Self {
        RV64Opnd::from(*opnd)
    }
}

/// List of registers that can be used for stack temps.
/// These are caller-saved registers.
pub static TEMP_REGS: [Reg; 5] = [X1_REG, X9_REG, X10_REG, X14_REG, X15_REG];

#[derive(Debug, PartialEq)]
enum EmitError {
    RetryOnNextPage,
    OutOfMemory,
}
